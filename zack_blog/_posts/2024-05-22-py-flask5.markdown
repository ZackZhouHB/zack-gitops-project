---
layout: post
title:  "Python Flask Microservice: K8S deployment"
date:   2024-05-22 1:17:29 +1100
categories: jekyll Cat2
---

<b> About K8S deployment</b>

Now It is time to change from docker-compose to deploy into Kubernetes.  

As this is not new to me to deploy microservice into K8S, also I already have a running Kubernetes cluster in hand, so here I will just create docker images for the 3 services: API gateway, user and order, then push them into the docker hub repository, then create Kubernetes manifest for deployment and service.  


{% highlight shell %}
# Folder structure
/07-with-k8s
.
├── api_gateway.py
├── depolyment.yaml
├── Dockerfile_apigateway
├── Dockerfile_order
├── Dockerfile_user
├── order_service.py
└── user_service.py

# Build, tag and push the docker images
docker login

docker build -t zackz001/python-user:latest -f Dockerfile_user .
docker build -t zackz001/python-order:latest -f Dockerfile_order .
docker build -t zackz001/python-apigateway:latest -f Dockerfile_apigateway .
docker push zackz001/python-apigateway:latest
docker push zackz001/python-user:latest
docker push zackz001/python-order:latest

docker image ls

REPOSITORY                                      TAG       IMAGE ID       CREATED        SIZE
zackz001/python-apigateway                      latest    bc3db11f4be8   1 hours ago    138MB
zackz001/python-user                            latest    c93973bece33   1 hours ago    136MB
zackz001/python-order                           latest    e35d5de9254b   1 hours ago    136MB
prom/prometheus                                 latest    1bd2b9635267   8 days ago     271MB
grafana/grafana                                 latest    c42c21cd0ebc   3 weeks ago    453MB
consul                                          1.15.4    686495461132   4 months ago   155MB
docker.elastic.co/elasticsearch/elasticsearch   7.13.2    11a830014f7c   3 years ago    1.02GB
docker.elastic.co/logstash/logstash             7.13.2    8dc1af4dd662   3 years ago    965MB
docker.elastic.co/kibana/kibana                 7.13.2    6c4869a27be1   3 years ago    1.35GB

# k8s deployment Manifests

apiVersion: apps/v1
kind: Deployment
metadata:
 name: user-service
spec:
 replicas: 1
 selector:
 matchLabels:
 app: user-service
 template:
 metadata:
 labels:
 app: user-service
 spec:
 containers:
 - name: user-service
 image: zackz001/python-user:latest
 ports:
 - containerPort: 5001

---
apiVersion: v1
kind: Service
metadata:
 name: user-service
spec:
 selector:
 app: user-service
 ports:
 - protocol: TCP
 port: 5001
 targetPort: 5001

---
apiVersion: apps/v1
kind: Deployment
metadata:
 name: order-service
spec:
 replicas: 1
 selector:
 matchLabels:
 app: order-service
 template:
 metadata:
 labels:
 app: order-service
 spec:
 containers:
 - name: order-service
 image: zackz001/python-order:latest
 ports:
 - containerPort: 5002

---
apiVersion: v1
kind: Service
metadata:
 name: order-service
spec:
 selector:
 app: order-service
 ports:
 - protocol: TCP
 port: 5002
 targetPort: 5002

---
apiVersion: apps/v1
kind: Deployment
metadata:
 name: api-gateway
spec:
 replicas: 1
 selector:
 matchLabels:
 app: api-gateway
 template:
 metadata:
 labels:
 app: api-gateway
 spec:
 containers:
 - name: api-gateway
 image: zackz001/python-apigateway:latest
 ports:
 - containerPort: 5000

---
apiVersion: v1
kind: Service
metadata:
 name: api-gateway
spec:
 type: NodePort
 selector:
 app: api-gateway
 ports:
 - protocol: TCP
 port: 5000
 targetPort: 5000

{% endhighlight %}

Now Run kubectl apply -f to bring all deployments and services up and running. Should see all services in the Rancher console.


{% highlight shell %}

kubectl create ns python

kubectl apply -f depolyment.yaml -n python

kubectl get all -n python

NAME                                 READY   STATUS    RESTARTS      AGE
pod/api-gateway-d664cf8c4-7l7q8      1/1     Running   2 (50m ago)   1h
pod/order-service-856577f666-gk5gt   1/1     Running   2 (50m ago)   1h
pod/user-service-5d8766d9cb-4rqnz    1/1     Running   2 (50m ago)   1h

NAME                    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
service/api-gateway     NodePort    10.43.38.27     <none> 5000:32060/TCP   1h
service/order-service   ClusterIP   10.43.27.255    <none> 5002/TCP         1h
service/user-service    ClusterIP   10.43.160.232   <none> 5001/TCP         1h

NAME                            READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/api-gateway     1/1     1            1           1h
deployment.apps/order-service   1/1     1            1           1h
deployment.apps/user-service    1/1     1            1           1h

NAME                                       DESIRED   CURRENT   READY   AGE
replicaset.apps/api-gateway-d664cf8c4      1         1         1       1h
replicaset.apps/order-service-856577f666   1         1         1       1h
replicaset.apps/user-service-5d8766d9cb    1         1         1       1h

{% endhighlight %}

<b> Verify API gateway, user and order services</b>

Access API gateway via http://NodeIP:NodePort/users and http://NodeIP:NodePort/orders 

![image tooltip here](/assets/flask11.png)

![image tooltip here](/assets/flask12.png)

<b> Conclusion</b>

Now we complete all Python Flask sessions. 

I have done this End-to-End Python Flask microservice application solution development, which enhanced my DevOps practices of Python programming, microservices architecture design and deployment with docker-compose, API Gateway implementation, service registery with Consul, logging and monitoring, and finally Kubernetes deployment.  

- simple Python Flask app

- Microservice applications with user and order

- Create API gateway Flask app

- Service registery with Consul

- Logging with ELK

- Monitoring with Prometheus and Grafana

- K8S deployment
