---
layout: post
title:  "Python Flask: Microservice Containerization"
date:   2024-05-18 11:15:29 +1100
categories: jekyll Cat2
---
<b> About Python Flask</b>

Flask stands out as one of Python’s most popular web frameworks. Designed for versatility and ease of use, Flask offers a robust starting point for crafting web apps.

By the following posts, I will use Flask to 

- create a series of Python web applications from simple app (Hello Zack)

- develop microservices applications (order and user), deploy using Docker compose

- Create Python API gateway application to 

- Integrate with Consul for service discovery and register

- Enable logging with ELK, monitoring with Prometheus & Grafana

- Last I will create Kubernetes manifast for K8S deployment. 

- I will skip ArgoCD and Github Action as I had done similar posts before.   

<b> Get started with Flask env and simple app</b>

I will skip the installation for Docker and python3 as those can be found via the official Docker and Python website.

{% highlight shell %}
# local create a new virtualenv 
virtualenv flask
# pip3 install virtualenv 
cd flask
# activate the virtualenv
source bin/activate

# install flask
pip install flask

# create a simple Flask app
vim app.py

from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello_zack():
 return 'Hello, Zack!'

if __name__ == '__main__':
 app.run(host='0.0.0.0', port=5000)

# run it
(flask) root@ubt-server:~/zack-gitops-project/Python-flask/01-single-app# python3 app.py 

 * Serving Flask app 'app'
 * Debug mode: off
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on all addresses (0.0.0.0)
 * Running on http://127.0.0.1:5000
 * Running on http://11.0.1.199:5000
Press CTRL+C to quit
11.0.1.1 - - [18/Jul/2024 13:50:41] "GET / HTTP/1.1" 200 -


{% endhighlight %}

![image tooltip here](/assets/flask1.png)


<b> Create "user" and "order" flask microservice apps</b>

Now I will move to create 2 microservice applications with Flask.

{% highlight shell %}

# order_service.py
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/orders')
def get_orders():
 orders = [
 {'id': 1, 'item': 'Laptop', 'price': 1200},
 {'id': 2, 'item': 'Phone', 'price': 800}
 ]
 return jsonify(orders)

if __name__ == '__main__':
 app.run(host='0.0.0.0', port=5002)


# user_service.py
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/users')
def get_users():
 users = [
 {'id': 1, 'name': 'Alice'},
 {'id': 2, 'name': 'Bob'}
 ]
 return jsonify(users)

if __name__ == '__main__':
 app.run(host='0.0.0.0', port=5001)

{% endhighlight %}

Create Dockerfile for containirztion

{% highlight shell %}

# Dockerfile-order

# Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory in the container
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY order_service.py /app

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir flask

# Make port 5002 available to the world outside this container
EXPOSE 5002

# Define environment variable
ENV FLASK_APP=order_service.py

# Run order_service.py when the container launches
CMD ["flask", "run", "--host=0.0.0.0", "--port=5002"]


# Dockerfile-order

# Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory in the container
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY user_service.py /app

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir flask

# Make port 5001 available to the world outside this container
EXPOSE 5001

# Define environment variable
ENV FLASK_APP=user_service.py

# Run order_service.py when the container launches
CMD ["flask", "run", "--host=0.0.0.0", "--port=5001"]

{% endhighlight %}

Build, tag and run it using docker-compose

{% highlight shell %}

# docker-compose.yml
version: '3'
services:
 user-service:
 build:
 context: .
 dockerfile: Dockerfile_user
 ports:
 - "5001:5001"
 order-service:
 build:
 context: .
 dockerfile: Dockerfile_order
 ports:
 - "5002:5002"

docker-compose up --build

Creating 02-microservice-docker-compose_user-service_1  ... done
Creating 02-microservice-docker-compose_order-service_1 ... done
Attaching to 02-microservice-docker-compose_order-service_1, 02-microservice-docker-compose_user-service_1
order-service_1  |  * Serving Flask app 'order_service.py'
order-service_1  |  * Debug mode: off
order-service_1  | WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
order-service_1  |  * Running on all addresses (0.0.0.0)
order-service_1  |  * Running on http://127.0.0.1:5002
order-service_1  |  * Running on http://192.168.16.3:5002
order-service_1  | Press CTRL+C to quit
user-service_1   |  * Serving Flask app 'user_service.py'
user-service_1   |  * Debug mode: off
user-service_1   | WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
user-service_1   |  * Running on all addresses (0.0.0.0)
user-service_1   |  * Running on http://127.0.0.1:5001
user-service_1   |  * Running on http://192.168.16.2:5001
user-service_1   | Press CTRL+C to quit


{% endhighlight %}

![image tooltip here](/assets/flask2.png)
![image tooltip here](/assets/flask3.png)

<b> Conclusion</b>

Now we can use Python flask to create a simple web application and containerized it using Dockerfile

In the next post, I will see how to use Python Flask to redesign Zack's blog for Web application development.
