pipeline {
    agent any
    environment {
        IMAGE_NAME = "zackz001/jenkins"
        IMAGE_TAG = "${env.BUILD_NUMBER}"
        LATEST_TAG = "latest"
        EMAIL_RECIPIENT = "zhbsoftboy1@gmail.com"
        GIT_REPO_URL = 'https://github.com/ZackZhouHB/zack-gitops-project.git'  // Git repository URL
        GIT_BRANCH = 'jenkins-cd'  // Git branch
        DOCKERHUB_CREDENTIALS_ID = 'dockerhub' // Docker Hub credentials
        REGION = 'ap-southeast-2'  // AWS region
    }
    stages {
//        stage('Clean Workspace') {
//            steps {
//                cleanWs()
//            }
//       }
        stage('Checkout Code') {
            steps {
                git branch: "${GIT_BRANCH}",
                    credentialsId: 'gittoken',
                    url: "${GIT_REPO_URL}"
            }
        }
        stage('Check Installed Package Versions') {
            steps {
                script {
                    try {
                        // Check Docker version
                        sh '''
                            if command -v docker >/dev/null 2>&1; then
                                echo "Docker Version: $(docker --version)"
                            else
                                echo "Docker is not installed"
                                exit 1
                            fi
                        '''
                    } catch (Exception e) {
                        echo "Error: Docker not found. ${e.message}"
                    }

                    try {
                        // Check Terraform version
                        sh '''
                            if command -v terraform >/dev/null 2>&1; then
                                echo "Terraform Version: $(terraform -version)"
                            else
                                echo "Terraform is not installed"
                                exit 1
                            fi
                        '''
                    } catch (Exception e) {
                        echo "Error: Terraform not found. ${e.message}"
                    }

                    try {
                        // Check Kubectl version
                        sh '''
                            if command -v kubectl >/dev/null 2>&1; then
                                echo "Kubectl Version: $(kubectl version --client)"
                            else
                                echo "Kubectl is not installed"
                                exit 1
                            fi
                        '''
                    } catch (Exception e) {
                        echo "Error: Kubectl not found. ${e.message}"
                    }

                    try {
                        // Check Trivy version
                        sh '''
                            if command -v trivy >/dev/null 2>&1; then
                                echo "Trivy Version: $(trivy --version)"
                            else
                                echo "Trivy is not installed"
                                exit 1
                            fi
                        '''
                    } catch (Exception e) {
                        echo "Error: Trivy not found. ${e.message}"
                    }

                    try {
                        // Check Ansible version
                        sh '''
                            if command -v ansible >/dev/null 2>&1; then
                                echo "Ansible Version: $(ansible --version)"
                            else
                                echo "Ansible is not installed"
                                exit 1
                            fi
                        '''
                    } catch (Exception e) {
                        echo "Error: Ansible not found. ${e.message}"
                    }

                    try {
                        // Check AWS CLI version
                        sh '''
                            if command -v aws >/dev/null 2>&1; then
                                echo "AWS CLI Version: $(aws --version)"
                            else
                                echo "AWS CLI is not installed"
                                exit 1
                            fi
                        '''
                    } catch (Exception e) {
                        echo "Error: AWS CLI not found. ${e.message}"
                    }
                }
            }
        }
        stage('Run a testing Ansible Playbook') {
            steps {
                script {
                    // Run the Ansible playbook using the hosts file from the repo
                    sh '''
                        echo "Running Ansible playbook:"
                        ansible-playbook -i "${WORKSPACE}/jenkins/terraform-ec2/hosts" "${WORKSPACE}/jenkins/terraform-ec2/test-playbook.yaml"
                    '''
                }
            }
        }
        stage('Verify AWS credential') {
            steps {
                withAWS(credentials: 'aws', region: 'ap-southeast-2') { // Replace with correct AWS credentials ID
                    script {
                        // List all existing S3 buckets and output the result to the Jenkins console
                        sh '''
                            echo "Listing all S3 buckets:"
                            aws s3 ls
                        '''
                    }
                }
            }
        }
        stage('Terraform Init and Apply') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws']]) {
                    script {
                        // Initialize and apply Terraform
                        sh '''
                            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                            cd jenkins/terraform-eks

                            terraform init
                            terraform validate
                            terraform apply -auto-approve -var "aws_region=${REGION}"

                            # Extract the cluster name from Terraform output
                            echo "Extracting EKS Cluster Name..."
                            echo "EKS_CLUSTER_NAME=$(terraform output -raw cluster_name)" > cluster_env_vars
                        '''
                        
                        // Load the cluster name into the environment variable for later stages
                        env.EKS_CLUSTER_NAME = sh(script: 'echo $(cat cluster_env_vars)', returnStdout: true).trim()
                        echo "Extracted EKS Cluster Name: ${env.EKS_CLUSTER_NAME}"  
                    }
                }
            }
        }

        // Stage to update kubeconfig for Jenkins to manage EKS cluster
        stage('Update Kubeconfig') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws']]) {
                    sh '''
                        export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                        export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}

                        # Update kubeconfig to access the EKS cluster
                        aws eks --region ${REGION} update-kubeconfig --name ${EKS_CLUSTER_NAME}

                        # Verify that the cluster is ready
                        kubectl get nodes
                    '''
                }
            }
        }

        // Stage to deploy the application
        stage('Deploy Application') {
            steps {
                sh '''
                    # Apply the Kubernetes deployment
                    kubectl apply -f jenkins/terraform-eks/deployment.yaml
                '''
            }
        }

        // Stage to wait for the deployment to be ready
        stage('Wait for Deployment') {
            steps {
                script {
                    def maxRetries = 10
                    def waitTime = 30 // seconds

                    // Check the deployment status
                    for (int i = 0; i < maxRetries; i++) {
                        // Check the deployment status
                        def status = sh(script: 'kubectl get deployment my-app -o jsonpath="{.status.availableReplicas}"', returnStdout: true).trim()

                        if (status == "2") {  // Change this based on your desired replicas
                            echo "Deployment is ready."
                            break
                        } else {
                            echo "Deployment is not ready yet. Waiting for ${waitTime} seconds..."
                            sleep waitTime
                        }
                    }
                }
            }
        }

        // Stage to output the LoadBalancer DNS name of the deployed service
        stage('Output LoadBalancer DNS Name') {
            steps {
                script {
                    // Retrieve the LoadBalancer DNS name
                    def loadBalancerDns = sh(script: 'kubectl get service my-app-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"', returnStdout: true).trim()
                    echo "LoadBalancer DNS Name: ${loadBalancerDns}"
                }
            }
        }

        // Stage to test the accessibility of the web application
        stage('Test Application Accessibility') {
            steps {
                script {
                    // Check if the LoadBalancer is ready
                    def loadBalancerDns = sh(script: 'kubectl get service my-app-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"', returnStdout: true).trim()
                    echo "LoadBalancer DNS: ${loadBalancerDns}"

                    // Test the accessibility of the web application
                    def response = sh(script: "curl -s -o /dev/null -w '%{http_code}' http://${loadBalancerDns}", returnStdout: true).trim()

                    if (response == "200") {
                        echo "Application is accessible!"
                    } else {
                        error "Application is not accessible! HTTP response code: ${response}"
                    }
                }
            }
        }
    }
    //    stage('Terraform destroy') {
    //       steps {
    //            withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws']]) {
    //               sh '''
    //                    export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
    //                    export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
    //                    cd jenkins/terraform-eks
    //
    //                    # Check if Terraform has been initialized
    //                    if [ ! -d ".terraform" ]; then
    //                        echo "Terraform not initialized. Running 'terraform init'..."
    //                        terraform init
    //                    else
    //                        echo "Terraform already initialized. Skipping 'terraform init'."
    //                    fi
    //
    //                    terraform destroy -auto-approve -var "aws_region=${REGION}"
    //                '''
    //            }
    //        }
    //    }              
    //}
    post {
        success {
            echo "Pipeline completed successfully."
        }
        failure {
            echo "Pipeline failed."
        }
    }
}
